package com.example.demo.services;

import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.example.demo.dto.CommentCommandToComment;
import com.example.demo.dto.CommentToCommentCommand;
import com.example.demo.dto.RecipeCommandToRecipe;
import com.example.demo.dto.RecipeToRecipeCommand;
import com.example.demo.exception.NotFoundException;
import com.example.demo.formcommand.CategoryCommand;
import com.example.demo.formcommand.CommentCommand;
import com.example.demo.formcommand.IngredientCommand;
import com.example.demo.formcommand.RecipeCommand;
import com.example.demo.model.Comment;
import com.example.demo.model.Ingredient;
import com.example.demo.model.Recipe;
import com.example.demo.repositories.RecipeRepository;



@Service
public class RecipeServiceImpl implements RecipeService {

	private final RecipeRepository recipeRepository;
	private final CategoryService categoryService;
	@SuppressWarnings("unused")
	private final IngredientService ingredientService;


	private RecipeCommandToRecipe recipeCommandToRecipe;
	private RecipeToRecipeCommand recipeToRecipeCommand;
	private CommentCommandToComment commentCommandToComment;
	@SuppressWarnings("unused")
	private CommentToCommentCommand commentToCommentCommand;

	private final static Logger log = LoggerFactory.getLogger(RecipeServiceImpl.class);

	public RecipeServiceImpl(RecipeRepository recipeRepository,
			CategoryService categoryService,
			RecipeCommandToRecipe recipeCommandToRecipe,
			RecipeToRecipeCommand recipeToRecipeCommand, 
			IngredientService ingredientService,
			CommentCommandToComment commentCommandToComment,
			CommentToCommentCommand commentToCommentCommand) {

		this.recipeRepository = recipeRepository;
		this.categoryService = categoryService;
		this.recipeCommandToRecipe = recipeCommandToRecipe;
		this.recipeToRecipeCommand = recipeToRecipeCommand;
		this.ingredientService = ingredientService;
		this.commentCommandToComment = commentCommandToComment;
		this.commentToCommentCommand = commentToCommentCommand;
	}

	@Override
	public Set<Recipe> getRecipes() {
		Set<Recipe> recipeSet = new HashSet<>();
		recipeRepository.findAll().iterator().forEachRemaining(recipeSet::add);
		return recipeSet;
	}

	@Override
	@Transactional
	public Recipe findById(long recipeId) {
		Optional<Recipe> recipeOpt = recipeRepository.findById(recipeId);
		if (! recipeOpt.isPresent()) {
			throw new NotFoundException("recipe not found");
		}
		return recipeOpt.get();
	}

	/**
	 * saveCommandRecipe save a recipe in db
	 */
	@Override
	@Transactional
	public Recipe saveCommandRecipe(RecipeCommand recipeCommand) {

		Recipe detachedRecipe = recipeCommandToRecipe.convert(recipeCommand);
		//remove empty ingredients
		Set<Ingredient> ingredients = new HashSet<>();
		//in ui we can add any empty ingredients so when we save we remove empty ingredients
		for (Ingredient ingredient : detachedRecipe.getIngredients()) {

			if (ingredient.getId() < 0) {
				//it's a new ingredient we had put a negative id in order to can remove it if user remove an unsaved ingredient
				// now we will save ingredient so we remove ingredient id because it must be auto generated by mysql
				ingredient.setId(null);
			}
			ingredients.add(ingredient);

		}
		detachedRecipe.setIngredients(ingredients);
		Recipe savedRecipe = recipeRepository.save(detachedRecipe);

		log.debug(String.format("Recipe id '{0}' is saved.", savedRecipe.getId()));
		return savedRecipe;
	}

	@Override
	@Transactional
	public RecipeCommand findRecipeCommandById(long recipeId) {

		Recipe recipe = this.findById(recipeId);
		RecipeCommand recipeCommand = this.recipeToRecipeCommand.convert(recipe);
		List<CategoryCommand>  commandCategories = this.categoryService.fillCommandCategories(recipeCommand.getCategories());
		recipeCommand.setCategories(commandCategories);

		return recipeCommand;
	}

	/**
	 * deleteById delete recipe in db
	 */
	@Override
	public void deleteById(long id) {
		this.recipeRepository.deleteById(id);
	}

	/**
	 * removeIngredient remove an ingredient to form only (not save in db)
	 */
	@Override
	@Transactional
	public RecipeCommand removeIngredient(RecipeCommand recipeCommand, long ingredientId) {

		IngredientCommand IngredientToRemove = null ;

		for (IngredientCommand ingredient : recipeCommand.getIngredients()) {
			if (ingredient.getId() == ingredientId) {
				IngredientToRemove = ingredient;
				break;
			}
		}
		//remove statement is out side the for each loop to escape ConcurrentModificationException
		if (null != IngredientToRemove) {
			recipeCommand.getIngredients().remove(IngredientToRemove);
		}

		//refill (checked and unchecked) categories
		recipeCommand.setCategories(this.categoryService.fillCommandCategories(recipeCommand.getCategories()));

		return recipeCommand;
	}

	/**
	 * addEmptyIngredient add ingredient to form only (not save in db)
	 */
	@Override
	public RecipeCommand addEmptyIngredient(RecipeCommand recipeCommand) {

		//the new ingredient are not saved, we don't know what will do the user so we put an temporary negative id 
		//( id is needed to delete an ingredient
		IngredientCommand newIngredient = new IngredientCommand();
		long randomid = (long) (Math.floor(Math.random() * 9_999_999_999L) + 9_000_000_000L)*(-1);

		newIngredient.setId(randomid);
		recipeCommand.getIngredients().add(newIngredient);
		recipeCommand.setCategories(this.categoryService.fillCommandCategories(recipeCommand.getCategories()));
		return recipeCommand;
	}

	/**
	 * saveRecipeComment save a comment in db
	 * @throws NotFoundException 
	 */
	@Override
	@Transactional
	public RecipeCommand saveRecipeComment(long recipeId, CommentCommand commentCommand) {

		Recipe recipe = this .findById(recipeId);
		Comment comment = this.commentCommandToComment.convert(commentCommand);
		comment.setDate(new Date());
		recipe.addComment(comment);

		Recipe savedRecipe = recipeRepository.save(recipe);
		RecipeCommand recipeCommandSaved = this.recipeToRecipeCommand.convert(savedRecipe);

		return recipeCommandSaved;
	}


	/**
	 * return a RecipeCommand filled by categories from database
	 */
	@Override
	public RecipeCommand getRecipeCommandWithAllCategories() {
		RecipeCommand commandRecipe =new RecipeCommand();
		commandRecipe.setCategories(this.categoryService.findAllCategoryCommand());
		return commandRecipe;
	}

}
