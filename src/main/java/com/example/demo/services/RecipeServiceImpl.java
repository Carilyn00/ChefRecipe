package com.example.demo.services;

import java.math.BigDecimal;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.example.demo.dto.RecipeCommandToRecipe;
import com.example.demo.dto.RecipeToRecipeCommand;
import com.example.demo.formcommand.CategoryCommand;
import com.example.demo.formcommand.IngredientCommand;
import com.example.demo.formcommand.RecipeCommand;
import com.example.demo.model.Comment;
import com.example.demo.model.Ingredient;
import com.example.demo.model.Recipe;
import com.example.demo.repositories.RecipeRepository;


@Service
public class RecipeServiceImpl implements RecipeService {

    private final RecipeRepository recipeRepository;
    private final CategoryService categoryService;
    @SuppressWarnings("unused")
	private final IngredientService ingredientService;
    
	private RecipeCommandToRecipe recipeCommandToRecipe;
	private RecipeToRecipeCommand recipeToRecipeCommand;

	
	private final static Logger log = LoggerFactory.getLogger(RecipeServiceImpl.class);

    public RecipeServiceImpl(RecipeRepository recipeRepository,
    		CategoryService categoryService,
    		RecipeCommandToRecipe recipeBeanToRecipe,
    		RecipeToRecipeCommand recipeToRecipeBean, 
    		IngredientService ingredientService) {
    	
    	this.recipeRepository = recipeRepository;
    	this.categoryService = categoryService;
        this.recipeCommandToRecipe = recipeBeanToRecipe;
        this.recipeToRecipeCommand = recipeToRecipeBean;
        this.ingredientService = ingredientService;
    }

	@Override
    public Set<Recipe> getRecipes() {
        Set<Recipe> recipeSet = new HashSet<>();
        recipeRepository.findAll().iterator().forEachRemaining(recipeSet::add);
        return recipeSet;
    }

	@Override
	public Recipe findById(Long id) {
		Optional<Recipe> recipeOpt = recipeRepository.findById(id);
	        if (! recipeOpt.isPresent()) {
				throw new RuntimeException("recipe not found");
			}
		return recipeOpt.get();
	}
	

	@Override
    @Transactional
	public Recipe saveCommandRecipe(RecipeCommand recipeBean) {
		
		Recipe detachedRecipe = recipeCommandToRecipe.convert(recipeBean);
		//remove empty ingredients
		Set<Ingredient> ingredients = new HashSet<Ingredient>();
		//in ui we can add any empty ingredients so when we save we remove empty ingredients
		for (Ingredient ingredient : detachedRecipe.getIngredients()) {
			if ( null == ingredient.getAmount()  || 
					ingredient.getAmount().compareTo(BigDecimal.ZERO) == 0 ||
					null == ingredient.getName() ||
					ingredient.getName().isEmpty()) {
				//nothing to do
			} else {
				if (ingredient.getId() > 0) {
					//it's a new ingredient we had put a negative id in order to can remove it if user remove an unsaved ingredient
					// now we will save ingredient so we remove ingredient id because it must be auto generated by mysql
					ingredient.setId(null);
				}
				ingredients.add(ingredient);
			}
			
		}
		detachedRecipe.setIngredients(ingredients);
        Recipe savedRecipe = recipeRepository.save(detachedRecipe);
        
        log.debug("Saved RecipeId:" + savedRecipe.getId());
        return savedRecipe;
	}

	@Override
	@Transactional
	public RecipeCommand findRecipeCommandById(Long id) {
		Recipe recipe = this.findById(id);
		RecipeCommand beanRecipe = this.recipeToRecipeCommand.convert(recipe);
		return beanRecipe;
	}
	
	@Override
	@Transactional
	public RecipeCommand findCompleteCommandRecipeById(Long id) {
		Recipe recipe = this.findById(id);
		RecipeCommand recipeCommand = this.recipeToRecipeCommand.convert(recipe);
		List<CategoryCommand>  commandCategories = this.categoryService.fillCommandCategories(recipeCommand.getCategories());
		recipeCommand.setCategories(commandCategories);
		
		return recipeCommand;
	}
	


	@Override
	public void deleteById(Long id) {
		this.recipeRepository.deleteById(id);
	}

	@Override
	public RecipeCommand removeIngredient(RecipeCommand recipe, long ingredientId) {
		
    	IngredientCommand IngredientToRemove = null ;

    	for (IngredientCommand ingredient : recipe.getIngredients()) {
			if (ingredient.getId() == ingredientId) {
				IngredientToRemove = ingredient;
				break;
			}
		}
    	//remove statement is not in the for each loop to escape ConcurrentModificationException
    	if (null != IngredientToRemove) {
    		recipe.getIngredients().remove(IngredientToRemove);
		}
    	
    	//refill (checked and unchecked) categories
    	recipe.setCategories(this.categoryService.fillCommandCategories(recipe.getCategories()));
    		
		return recipe;
	}
	
	@Override
	public RecipeCommand addEmptyIngredient(RecipeCommand CommandRecipe) {
		
		//the new ingredient are not saved, we don't know what will do the user so we put an temporary negative id 
		//( id is needed to delete an ingredient
		IngredientCommand newIngredient = new IngredientCommand();
		long randomid = (long) (Math.floor(Math.random() * 9_999_999_999L) + 9_000_000_000L)*(-1);

		newIngredient.setId(randomid);
		CommandRecipe.getIngredients().add(newIngredient);
		/*
		Recipe recipe = this.recipeCommandToRecipe.convert(CommandRecipe);
		recipe.getIngredients().add(new Ingredient());
		Recipe savedRecipe = recipeRepository.save(recipe);
        log.debug("Saved RecipeId:" + savedRecipe.getId());
        CommandRecipe recipeCommand = findCompleteBeanById(savedRecipe.getId());
        */
        return CommandRecipe;
	}

	@Override
	public Recipe addComment(long recipeId, Comment comment) {
		Recipe recipe = findById(recipeId);
		comment.setId(null);
		recipe.addComment(comment);
		comment.setDate(new Date());
		Recipe savedRecipe = recipeRepository.save(recipe);
		
		return savedRecipe;
	}

}
